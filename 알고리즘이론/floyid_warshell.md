#### Floyid Warshell 알고리즘
- 최단경로 알고리즘
-  벨만포드, 다익스트라와 다르게 정점 V개가 있고, 거리가 다 주어져 있을떄, ```단 한번의 시행으로 모든 정점 쌍의 사이의 거리를 다구해냄```
- 시간복잡도는 3중 for문 형태로 O(V^3)
- 음의 가중치도 가능
##### 대표 문제 boj 11404 플로이드
- 전처리(그래프 모델링)
	- 각 정점 u,v 쌍에대해 u에서 v로 가는 최단경로를 한번에구함
	- 이를 위한 2차원 배열 dist 준비
	- 초기에는 dist[i][i](자기자신으로) 가는 배열은 0  나머지는 INF설정
	- 간선(Edge) 정보들을 입력받아서 u->w로가는 거리 w이면 dist[u][v]=w로 갱신
	- 혹시라도 똑같은 u,v 쌍에 대해서 서로다른 w가 두번이상 들어올수 있는데, 이때는 그 중 가장 작은것을 갱신
- 플로이드 알고리즘 적용
	- 플로이드는 최단경로를 DP형태 문제로 정의
	- shorthesPath(i,j, k) 라는 문제는 i번정점에서 j번 정점까지, 1~k번 정점만 사용할때의 최단 거리를 구함
	- K단계 문제를 풀려면 k-1단계의 정보가 필요한데 그래서 k=1~N까지 시도하며 정보를 계속해서 갱신
	- 이떄 k-1단계 이전의 정보를 더이상 필요하지않으므로 ``` 3차원 배열이 아닌 슬라이딩 윈도우 기법```을 활용 (2차원만으로 가능)
	- 이걸 비슷하게 벨만 포드 알고리즘과 비슷하게 k번 루프를 돌려보면 마지막엔 더 이상 갱신되지 않는 최단 경로 배열 dist가 완성
	- 매 단계에서는
		- 이번이 K단계 즉, 1-k번정점을 사용하여 도달가능한 최단 거리 구하는 단계
		- 지금까지 dist 배열에는 1~k-1번 정점만 사용해서 나올 수 있는 최단거리가 남아있음
		- 이걸 사용해서 갱신
		- 어떤 두 정점 i,j에 대해 k번 정점을 이용해서 우회하면 지금까지 최단 거리보다 짧아지는가?
		- ``` if ( dist[i][j] > dist[i[[k] + dist[k][j) ) 이면 갱신```
		- 
