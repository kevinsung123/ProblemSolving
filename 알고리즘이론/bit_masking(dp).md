### 비트마스킹(bit masking)
-   외판원 순회문제(TSP,Traveling Salesman Problem)
-  문제 : N개의 마을이 있고 외판원이 어늘 마을에서 시작하여 모든 마을을 한번씩만 방문하고 시작점으로 돌아올떄 ```최단경로```를 구하라
- 거리 Kl이하로 순회를 끝낼 수 있는 문제만 해도 NP에 속하고, 최단거리르 구하라고 묻는다면 NP에 속하고 그보다 어려운 영역인 PSPACE도 넘어버리는 문제
- N이 극히 작을떄 푸는방법  ```다이나믹 프로그래밍```
- tsp(current Town, visited) : 현재 currentTOw에 있고 visited에 속한 마을들을 이미 방문하였을떄, 방문하지 않은 마을들을 순회하여 시작점으로 돌아가는 최단 거리 
- basecase는 모든마을을 방문한경우 , 이떄 시작ㅈ머이 어딘지는 명시하지는 않았는데, 그 이유는 무조건1번 마을부터 싲가해도 되기 떄문임
![enter image description here](https://postfiles.pstatic.net/20160813_172/kks227_14710886489520VNX0_PNG/1.png?type=w3)
- 이 문제에서 정답인 경로는 항상 싸이클 
- 경로에 속하는 정점을 한번씩만 방문해야하고, 시작점으로 돌아와야함
-  여기서 문제는 ``` visited 를 어떻게 매개변수로 넘겨주느냐```
-  visited 라는 상태를 정수형으로 표현하기 위해 이제부터 비트마스크 사용
- 마을번호를 0부터 시작
- 마을이 N개일떄 N비트정수를  사용
- 예제 N=4
	- 0000 ~ 1111 즉, 0-15, 경우의수 16개, 각자리는 각가 2의 n승
	- k번비트, k번 자리 = k번 자리는 k번 마을을 방문했으면  1 아니면 0 
	- 아무것도 방문하지 않은 청므에는 0000으로 시작, 무조건 0번마을부터 방문할 것 이라면 0001로 시작
	- 재귀호출시 , 넘겨주는 상태는 0011이 될것이고 그 다음 3번 마을을 방문하면 1011, 그 다음 2번 마을 방문시 1111 이고 되고 base case가된다
	- 모든 비트0인지 확인은 단순휘 0과 비교 모든 비트 1인지 확인 2의 N-1과 같은지 비교하면 된다 => ``` (1<<N)-1```과 비교
	-  보통 상태가 주어졌을대 필요한 연산
		1. k번비트가 1인지 0인지 확인
		2. k번 비트를 1로 만들고 싶다
		3. k번 비트를 0으로 만들고 싶다
-  1번 경우 해당 비트값만 떼어놓고 나머지를 버려야함 
	- ``` status & (1<<k)``` 과 비교 
- 2번 경우 k번 비트 값만 조작 ```status = status | (1<<k)```
	- 이렇게 k번 비트만 1인 값과 bit OR연산을 하면 그 결과는 status에 k번비트를 무조건 1로 만드는 값이 되고 이것으로 덮어씌움
- 3번 경우 
	- ``` status = status & ~(1<<k) ```
	- k번비트만 0이고 나머지는 1인 값을 bit Not 연산으로 만듬
	- 그것과 bit AND연산을 하면 나머지는 status의 본래값이 되고 k번자리는 반드시 0이 된다 
